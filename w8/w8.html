<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">

  <link rel="stylesheet" type="text/css" href="../stylesheets/stylesheet.css" media="screen">
  <link rel="stylesheet" type="text/css" href="../stylesheets/github-dark.css" media="screen">
  <link rel="stylesheet" type="text/css" href="../stylesheets/print.css" media="print">
  <link rel="stylesheet" href="../stylesheets/mine.css">
  <link rel="stylesheet" href="cssgal.css">
  <title>8:-Embedded Programming</title>
</head>

<body>
  <link rel="icon" type="image/png" href="../favicon.png">
  <header>
    <div class="container">
      <h1>Fab2016</h1>
      <h3>/ Module 8</h3>

      <section id="Module">
        <a href="../index.html">Home</a>
        <a href="../w1/w1.html" class="btn" title="Principles and Practices, Project Management ">1</a>
        <a href="../w2/w2.html" class="btn" title="Computer-Aided Design">2</a>
        <a href="../w3/w3.html" class="btn" title="Computer-Controlled Cutting">3</a>
        <a href="../w4/w4.html" class="btn" title="Electronics Production">4</a>
        <a href="../w5/w5.html" class="btn" title="3D Scanning and Printing">5</a>
        <a href="../w6/w6.html" class="btn" title="Electronics Design">6</a>
        <a href="../w7/w7.html" class="btn" title="Computer-Controlled Machining">7</a>
        <a href="../w8/w8.html" class="btn" title="Embedded Programming">8</a>
        <a href="../w9/w9.html" class="btn" title="Mechanical Design">9</a>
        <a href="../w10/w10.html" class="btn" title="Machine Design">10</a>

      </section>
    </div>
  </header>
  <section>

    <h1>Embedded Programming</h1>
    <p>
      Goals for this module includes
      <ul>
        <li>Go through the microcontroller/microprocessor data sheets and document what I have learned.</li>
        <li>Program a 'Hello World' board I made before; in my case, the Fabduino variant I made
          <a href="../w6/w6.html">before</a>.</li>
        <li>Try different options to program the board; I'm planning to try Arduino IDE, pure C (avr-c) and assembly.</li>
        <li>For extra credit, try a different architecture.</li>
      </ul>
    </p>
    <p>
      I have already programmed my board using Arduino IDE. I spent some time setting up the Arduino environment, added the new 20MHz variant to the list of the boards (boards.txt), added
      new bootloader and new makefile. I also setup the Udev rules and few other tweaks, you can read about those in my
      <a href="../w6/w6.html">Electronics Design</a> page.
      <br> I didn't make the bootloader hex file or the makefile, I just sources it from various locations in Internet, so this is the time to learn about those too, means I will be trying
      to compile my own Arduino bootloader and Makefile.
    </p>
    <h2>So my goals for this module is.</h2>
    <p>
      <ol>
        <li>Go through the microcontroller/microprocessor data sheets and document what I have learned.</li>
        <li>Try Arduino IDE, AVR-C and assembly to program the Fabudino.</li>
        <li>Try making the Arduino bootloader for the 20MHz Fabduino.</li>
        <li>Create a makefile for compiling the avr-c code and programming.</li>
        <li>Since I have access to AVR and PIC boards as well as ARM (Raspberry PI), I may try some of them.</li>
      </ol>
    </p>
    <p>
      So I have downloaded the datasheet for the 8bit AVR microcontrollers,
      <a href="http://www.atmel.com/images/atmel-8271-8-bit-avr-microcontroller-atmega48a-48pa-88a-88pa-168a-168pa-328-328p_datasheet_complete.pdf">ATmega48A/PA/88A/PA/168A/PA/328/P
      </a>. I will be going through this documentation as and when I require.
      <br> For those who are interested in the board I'm using; this is a 20MHz variant of the Fabduino I made during
      <a href="../w6/w6.html">Electronics Design</a>.
      <br>
      <b>So, Lets begin....</b>
    </p>

    <h2>Programming With Arduino IDE and AVR C.</h2>
    <p>
      <h4 style="color:orange">The Arduino Code </h4>For Blinking the LED.
      <pre>
void setup() {
  // initialize digital pin 13 as an output.
  pinMode(13, OUTPUT);
}

void loop() {
  digitalWrite(13, HIGH);   // turn the LED on (HIGH is the voltage level)
  delay(1000);              // wait for a second
  digitalWrite(13, LOW);    // turn the LED off by making the voltage LOW
  delay(1000);              // wait for a second
}
      </pre>
      <h4 style="color:orange">The AVR C Code</h4> Essentially the same code as above.
      <pre>
#define F_CPU 20000000UL
#include &ltavr/io.h&gt
#include &ltutil/delay.h&gt

#define BLINK_DELAY_MS 1000

int main (void)
{
  /* set (PB5) of PORTB for output*/
  //DDRB = (1&lt&ltPB5);
  DDRB = 0b00100000; //does the same thing as above line
  while(1)
  {
    /* pin 5 high = turn led on */
    PORTB = 0b00100000;
    _delay_ms(BLINK_DELAY_MS);
    /* pin 5 low = turn led off */
    PORTB = 0b00000000;
    _delay_ms(BLINK_DELAY_MS);
  }
}
      </pre> This code is written with the help of datasheet of the AtMega328p, specifically section 14.2 on
      <b>Ports as General Digital I/O</b> and my own experience.
      <br> The following shell script was written to automate the compilation and uploading.
      <pre>
rm out*
avr-gcc -Os -DF_CPU=20000000UL -mmcu=atmega328p -c -o out.o blink0.1.c
avr-gcc -mmcu=atmega328p out.o -o out
avr-objcopy -O ihex -R .eeprom out out.hex
avrdude -F -V  -p ATMEGA328P -P usb -c usbtiny -b 115200 -U flash:w:out.hex

      </pre>
    </p>
    <br>
    <b style="color:green"> It's working, but, </b>
    <br>

    <h3 style="color:red">We Have A Problem</h3>
    <p>
      <video width="520" controls>
        <source src="timing-1.m4v" type="video/mp4"> Your browser does not support the video tag.
      </video>
      <br> The video has two boards, an Arduino UNO clone based on Atmega328p but working at 16MHz and my board, based on the same chip but working at 20MHz. Both the boards are running
      the same code for blinking the LED, one second on and one second off.
      <br> As you can see, my board is clearly not pulsing with one second delay, it's way above one second. Something is wrong, and I guess it's the clock speed. I defined 20MHz clock
      in program and during compilation and the chip is not running at a lower clock. So if the chip was indeed working at 20MHz I wouldn't face such an error. So I suspect three things,
      <ol>
        <li>I used a 8MHz resonator, (that is the only other resonator we have in the inventory)</li>
        <li>The connection/soldering of the resonator/IC pins is not proper.</li>
        <li>The chip was programmed with wrong FUSE bits when I programmed it the first time, I don't exactly rememberer what values I used. So if I had messed up here the chip may not
          accept external clock.</li>
      </ol>
    </p>
    <h4>So Why Is Clock Important?</h4>
    <p>
      For normal operations the clock is not necessary, for example you want your board to control some appliances based on some user inputs, such as turn on the lights when the sun goes
      down, or a solar tracker using a few motors(not servos or steppers) and light sensors.
      <br> But for anything where the timing is important, such as communication, servo/stepper/BLDC motor control etc. or even the simple blinking LED program require precise timing. The
      Microcontroller should work at a precise known clock speed, else we will have no control over the 'time'.
      <br> From the datasheet, I know that the chip has an internal clock and independent watchdog timers (I will explore this later). The internal clock is limited to 8MHz, you may be
      overclock it and get higher clock speed, but that's not good, because the internal clock generator is unreliable above 8Mhz, so time critical functions such as communication will
      fail. For any value above 8MHz, upto a limit of 20MHz we can use external clock.
    </p>
    <h4>'Time' To Fix The 'Timing'</h4>
    <p>
      First thing I did is to see what happens if I compile the program with <code>-DF_CPU=8000000UL</code> instead of<code>-DF_CPU=20000000UL</code>.
      <br> As expected the LED starts blinking with one Second delay; so the problem is what is suspected, chip running at lower clock.
      <br> First I tried too read the FUSE bits.
      <br>
      <pre>
        sibu@manjaro emb % avrdude -P usb -b 19200 -c usbtiny -p m328p -v

         avrdude: Version 6.3, compiled on Feb 21 2016 at 13:33:25
         Copyright (c) 2000-2005 Brian Dean, http://www.bdmicro.com/
         Copyright (c) 2007-2014 Joerg Wunsch

         System wide configuration file is "/etc/avrdude.conf"
         User configuration file is "/home/sibu/.avrduderc"
         User configuration file does not exist or is not a regular file, skipping

         Using Port                    : usb
         Using Programmer              : usbtiny
         Overriding Baud Rate          : 19200
         avrdude: usbdev_open(): Found USBtinyISP, bus:device: 001:011
         AVR Part                      : ATmega328P
         Chip Erase delay              : 9000 us
         PAGEL                         : PD7
         BS2                           : PC2
         RESET disposition             : dedicated
         RETRY pulse                   : SCK
         serial program mode           : yes
         parallel program mode         : yes
         Timeout                       : 200
         StabDelay                     : 100
         CmdexeDelay                   : 25
         SyncLoops                     : 32
         ByteDelay                     : 0
         PollIndex                     : 3
         PollValue                     : 0x53
         Memory Detail                 :

                                  Block Poll               Page                       Polled
           Memory Type Mode Delay Size  Indx Paged  Size   Size #Pages MinW  MaxW   ReadBack
           ----------- ---- ----- ----- ---- ------ ------ ---- ------ ----- ----- ---------
           eeprom        65    20     4    0 no       1024    4      0  3600  3600 0xff 0xff
           flash         65     6   128    0 yes     32768  128    256  4500  4500 0xff 0xff
           lfuse          0     0     0    0 no          1    0      0  4500  4500 0x00 0x00
           hfuse          0     0     0    0 no          1    0      0  4500  4500 0x00 0x00
           efuse          0     0     0    0 no          1    0      0  4500  4500 0x00 0x00
           lock           0     0     0    0 no          1    0      0  4500  4500 0x00 0x00
           calibration    0     0     0    0 no          1    0      0     0     0 0x00 0x00
           signature      0     0     0    0 no          3    0      0     0     0 0x00 0x00

         Programmer Type : USBtiny
         Description     : USBtiny simple USB programmer, http://www.ladyada.net/make/usbtinyisp/
         avrdude: programmer operation not supported

         avrdude: Using SCK period of 10 usec
         avrdude: AVR device initialized and ready to accept instructions

         Reading | ################################################## | 100% 0.00s

         avrdude: Device signature = 0x1e950f (probably m328p)
         avrdude: safemode: hfuse reads as DE
         avrdude: safemode: efuse reads as FD

         avrdude: safemode: hfuse reads as DE
         avrdude: safemode: efuse reads as FD
         avrdude: safemode: Fuses OK (E:FD, H:DE, L:FF)

         avrdude done.  Thank you.
      </pre> Okay,
      <strike>it seems that I haven't set any lfuse or hfuse. But I don't think</strike> So the last couple of lines suggest that I have indeed set the fuses, so that is the cause. Let us explore
      further, I'm going to check the Resonator using the DSO. Actually, if there were no fuses set, the AVR will run at default value of 1MHz, the fuse values set here says the chip
      to expect for an external clock source, as per the DATASHEET.
      <br>
      <figure>
        <img src="debug1.jpg" alt="debug-1" width="500" onmouseover="this.width='1300'" onmouseout="this.width='500'">
        <figcaption style="display:block; color:grey">DSO CH1 connected to the LED pin. As you can see the time period is about 5sec, hence the actual delay is 2.5sec, means the actual Freq is 20MHz/2.5 = 8Mhz! just as expected.</figcaption>
        <img src="debug2.jpg" alt="debug-2" width="500" onmouseover="this.width='1300'" onmouseout="this.width='500'">
        <figcaption style="display:block; color:grey">Examining the Resonator, DSO CH1 to one of the pin (other than the middle, GND) of the resonator. Confirmed my suspicion, the resonator was indeed 8MHz, people tends to mix
          items in the component bays!</figcaption>
      </figure>
      <br> Anyway, my board is working fine now, no timing issues.
    </p>
    <p>
      <h3>Assembly code for Blinking LED.</h3>
      <br> For the assembly code, we need to create a delay between toggling the LEDs. There are no pre-built functions like <code>_delay_ms();</code> in C or <code>delay();</code> in Arduino
      IDE. One method is to waste clock cycles, just like the functions <code>_delay_ms();</code> in C or <code>delay();</code> in Arduino does. But we will have to write our own routine
      for this. We can waste clock cycles by making the chip loop through a few calculations or something, since we can calculate how many clock cycles are required by each of those
      instructions and we know the time period of the clock, we can calculate the length of the loop so that we get a desired delay by executing this routine.
    </p>
    <p>
      I found a few sources which would help me do this
      <ul>
        <li>
          <a href="http://stackoverflow.com/questions/24097526/how-to-make-a-delay-in-assembly-for-avr-microcontrollers">http://stackoverflow.com/questions/24097526/how-to-make-a-delay-in-assembly-for-avr-microcontrollers</a>
        </li>
        <li>
          <a href="http://bretmulvey.com/avrdelay.html">http://bretmulvey.com/avrdelay.html</a>
        </li>
      </ul>
      <pre>
.equ	DDRB	, 0x04
.equ	PORTB	, 0x05

.org 0
jmp 16
.org 16

wdr

main:
    ldi r16, 0b00100000
    out DDRB,r16            ; Set PB5 to output
    out PORTB,r16           ; Set PB5 high

loop:
    call delay
    sbi PORTB, 5
    call delay
    cbi PORTB, 5
    rjmp loop
delay:
    ldi  r18, 102
    ldi  r19, 118
    ldi  r20, 194
L1: dec  r20
    brne L1
    dec  r19
    brne L1
    dec  r18
    brne L1
    ret
      </pre> The delay cycle is from
      <a href="http://www.bretmulvey.com/avrdelay.html">http://www.bretmulvey.com/avrdelay.html</a>.
    </p>
    <p>
      wasting the clock cycles to blink LED is not an ideal solution, in fact this is a waste of time. The chip is actually capable of doing much more and blinking an LED shouldn't consume
      all the resources. The solution is to use Internal/External Timers and interrupts. There are three timers in Atmeg328P, out of which one, Timer1 is a 16bit timer/counter. The
      other two, Timer0 and Timer2 are 8bit/timer/counter. There is a separate 128KHz watchdog timer too these timers/counters can be used to trigger corresponding interrupts and the
      interrupt routine can have the instructions to toggle the LEDs.
    </p>

    <h2>Interrupt Based Blink LED Program.</h2>
    <p>
      <h3 style="color:orange">Arduino code.</h3>
      <br>
      <pre>
// Arduino timer CTC interrupt example
#include &ltavr/io.h&gt
#include &ltavr/interrupt.h&gt
#define LEDPIN 13
void setup()
{
pinMode(LEDPIN, OUTPUT);
// initialize Timer1
cli();          // disable global interrupts
TCCR1A = 0;     // set entire TCCR1A register to 0
TCCR1B = 0;     // same for TCCR1B

// set compare match register to desired timer count:
OCR1A = 19530;

// turn on CTC mode:
TCCR1B |= (1 &lt&lt WGM12);

// Set CS10 and CS12 bits for 1024 prescaler:
TCCR1B |= (1 &lt&lt CS10);
TCCR1B |= (1 &lt&lt CS12);

// enable timer compare interrupt:
TIMSK1 |= (1 &lt&lt OCIE1A);

// enable global interrupts:
sei();
}

void loop()
{
// main program
}

ISR(TIMER1_COMPA_vect)
{
digitalWrite(LEDPIN, !digitalRead(LEDPIN));
}
      </pre> The program is from
      <a href="https://arduinodiy.wordpress.com/2012/02/28/timer-interrupts/">https://arduinodiy.wordpress.com/2012/02/28/timer-interrupts/</a>
      <br> The program counts till a number <code>x</code> and when the counter reaches <code>x</code> it triggers an interrupt. This mode is called
      <b>Clear Timer on Compare Match</b>, or
      <b>CTC</b>. The interrupt routine has the code to toggle the LED.
      <br>
      <figure>
        <img src="tccr1b-2.png" width="600" onmouseover="this.width='1000'" onmouseout="this.width='600'" />
        <figcaption style="display:block; color:grey">TCCR1B register controlling the Timer1.</figcaption>
        <img src="tccr1b-1.png" width="600" onmouseover="this.width='1000'" onmouseout="this.width='600'" />
        <figcaption style="display:block; color:grey">A table from the Datasheet explaining how to set various modes of operations of the Timer1.</figcaption>
        <img src="prescale.png" width="600" onmouseover="this.width='1000'" onmouseout="this.width='600'" />
        <figcaption style="display:block; color:grey">A table from the Datasheet explaining how to set the prescaler.</figcaption>
      </figure>
      As you can see I set the <code>WGM12</code> bit high to enable CTC mode, <code>CS10</code> and <code>CS12</code> bits are set high to enable 1024 prescaler, this means for every
      1024 clock cycles the counter will increase by one.
      <br>
      <br>
      <code>OCR1A</code> is a 16bit register to store the target count, and when the counter reaches this number it will trigger an interrupt vectored to <code>0x0016</code> or <code>TIMER1_COMPA_vect</code>.
      We can keep our 'toggle LED' program here.
      <br>
      <br>
      <code>OCIE1A</code> bit of <code>TIMSK1</code> register should be set high to enable the Timer1 compare interrupt, interrupt when the timer reaches the values set at <code>OCR1A</code>.
    </p>

    <br>
    <br>

    <h3>How do we calculate the value of <code>OCR1A</code>???</h3>
    <p>
      We know that the Timer1 increases by one for every 1024 system clock. Suppose the system clock is at <code>F Hz</code>, the period or the time resolution is <code>1/F</code> seconds.
      So the Timer one takes <code>1024 * 1/F</code> or <code>1024/F</code> seconds per increment. So for <code>t</code> seconds of delay, we will have <code>t*F/1024</code> counts
      in the Timer1. So this is the value we need to keep at <code>OCR1A</code> for a <code>t</code> second delay.
      <br>
      <br> To be very precise the calculation is actually <code>OCR1A = (t*F/prescale) - 1</code>. The extra <code>-1</code> is to compensate the extra clock cycle required for resetting
      the Timer1 back to Zero when it reaches the target.
      <br>
      <br>
      For 20MHz clock frequency, and 1 second delay this number would be <code>19530</code>.
    </p>

    <p>
      <br>
      <br>
      <h3 style="color:orange">Same Program Written in C would like like this.</h3>
      <pre>
//timer CTC interrupt test
#define F_CPU 20000000UL
#include &ltavr/io.h&gt
#include &ltavr/interrupt.h&gt

int temp=0;
int delay=1;
int main(void)
{
	DDRB = 0b00100000;
	PORTB = (0b00100000);
	// initialize Timer1 the 16bit timer
	cli();				// disable global interrupts
	TCCR1A = 0;
	TCCR1B = 0;		// same for TCCR1*

	// set compare match register to desired timer count:
	OCR1A = 19530;

	// turn on CTC mode:
	TCCR1B |= (1 &lt&lt WGM12);

	// Set CS10 and CS12 bits for 1024 prescaler:
	TCCR1B |= (1 &lt&lt CS10);
	TCCR1B |= (1 &lt&lt CS12);

	// enable timer compare interrupt:
	TIMSK1 |= (1 &lt&lt OCIE1A);

	sei();			// enable global interrupts:

	while(1)
	{
					//  my program
	}
}

ISR(TIMER1_COMPA_vect)
{
	if (temp==1)
	{
		PORTB = (0b00100000);
		temp=0;
	}
	else
	{
		PORTB = (0b00000000);
		temp=1;
	}
}

      </pre>
    </p>
  </section>

</body>

</html>
