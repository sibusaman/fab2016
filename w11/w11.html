<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">

  <link rel="stylesheet" type="text/css" href="../stylesheets/stylesheet.css" media="screen">
  <link rel="stylesheet" type="text/css" href="../stylesheets/github-dark.css" media="screen">
  <link rel="stylesheet" type="text/css" href="../stylesheets/print.css" media="print">
  <link rel="stylesheet" href="../stylesheets/mine.css">
  <link rel="stylesheet" href="cssgal.css">
  <title>11:-Input Devices</title>
  <style>
    div.codescroll {
      width: 1500px;
      height: 500px;
      overflow: scroll;
    }
  </style>
</head>

<body>
  <link rel="icon" type="image/png" href="../favicon.png">
  <header>
    <div class="container">
      <h1>Fab2016</h1>
      <h3>/ Module 11</h3>

      <section id="Module">
        <a href="../index.html">Home</a>
        <a href="../w1/w1.html" class="btn" title="Principles and Practices, Project Management ">1</a>
        <a href="../w2/w2.html" class="btn" title="Computer-Aided Design">2</a>
        <a href="../w3/w3.html" class="btn" title="Computer-Controlled Cutting">3</a>
        <a href="../w4/w4.html" class="btn" title="Electronics Production">4</a>
        <a href="../w5/w5.html" class="btn" title="3D Scanning and Printing">5</a>
        <a href="../w6/w6.html" class="btn" title="Electronics Design">6</a>
        <a href="../w7/w7.html" class="btn" title="Computer-Controlled Machining">7</a>
        <a href="../w8/w8.html" class="btn" title="Embedded Programming">8</a>
        <a href="../w9/w9.html" class="btn" title="Mechanical Design">9</a>
        <a href="../w10/w10.html" class="btn" title="Machine Design">10</a>
        <a href="../w11/w11.html" class="btn" title="Input Devices">11</a>
        <a href="../w12/w12.html" class="btn" title="Molding and Casting">12</a>
        <a href="../w13/w13.html" class="btn" title="Output Devices">13</a>

      </section>
    </div>
  </header>
  <section>

    <h1>Input Devices</h1> and output devices
    <p>
      <h3 style="color:red">NOTE:- This is a combined assignment for both Input devices and Output Devices modules, the input is the rotary switch and the output devices are the stepper or servo motors as
        well as the two LEDs. </h3>
    </p>
    <br>
    <br>
    <br>
    <br>
    <br>
    <p>
      For this week we are expected to experiment with input devices, to read some data from some sensor or some other source. We can use a wide variety of sensors available. The input can
      be as simple as a digital high/low state, or slightly complicated analogue signal which can be read using ADC, or more complicated serial communication protocols like I2C.
    </p>

    <h2>2-in one Stepper/Servo Tester with Rotary Switch.</h2>
    <p>
      As a first step I plan to make a single board to control a stepper motor or a servo motor with a rotary switch as an input. The rotation of the switch will be read and the appropriate
      motor will rotate in the corresponding direction. The built-in push button will be used to change the mode of operation, to begin with just two modes, one to control the servo
      another to control the stepper. There will be two LEDs to indicate various aspects like
      <br>..mode of operation
      <br>..direction of rotation etc.
    </p>
    <p>
      <figure>
        <img src="schem.png" alt="original schematic" width="600" onmouseover="this.width='1800'" onmouseout="this.width='600'" />
        <figcaption style="display:block; color:grey">Original Schematic.</figcaption>

        <img src="board.png" alt="original board" width="400" onmouseover="this.width='1800'" onmouseout="this.width='400'" />
        <figcaption style="display:block; color:grey">Original Board layout.</figcaption>

        <img src="top.png" alt="original schematic" width="300" onmouseover="this.width='800'" onmouseout="this.width='300'" />
        <img src="top-64.png" alt="original schematic" width="300" onmouseover="this.width='800'" onmouseout="this.width='300'" />
        <img src="top-32.png" alt="original schematic" width="300" onmouseover="this.width='800'" onmouseout="this.width='300'" />
        <figcaption style="display:block; color:grey">The top layer, the traces only for milling with 1/64" bit in MDX-20 and cutting file for use with 1/32" bit.</figcaption>
      </figure>
      <br>
      <h4>Eagle files for download:-&gt;</h4>
      <a href="ss-test.sch" download="sibu-stepper-servo-tester.sch">Schematic</a>.
      <a href="ss-test.brd" download="sibu-stepper-servo-tester.lbr">Board</a>.
    </p>
    <p>
      This is the picture of the completed board populated, except for the A4988 motor driver.
      <br>
      <figure>
        <img src="step-ser.jpg" alt="picture of the populated pcb" width="600" onmouseover="this.width='1800'" onmouseout="this.width='600'" />
        <figcaption style="display:block; color:grey">Populated pcb.</figcaption>
      </figure>
      <br> Notice the two extra wires, this is because I had to edit the board slightly, because I made a stupid mistake. I had connected the <code>MOSI</code> pin to the Rotary switch,
      this has been causing a lot of trouble. As the <code>MOSI</code> pin is always kept high or low depending on the position of the Rotary switch. Because of this, the ISP cannot
      program the board. So I had the following modification.
      <figure>
        <img src="schem-mod1.png" alt="original schematic" width="600" onmouseover="this.width='1800'" onmouseout="this.width='600'" />
        <figcaption style="display:block; color:grey">Modified Schematic,
          <b style="color:white">WHITE</b> is the deleted (removed) trace and
          <b style="color:green">GREEN</b> is the new connection made.</figcaption>

        <img src="board-mod1.png" alt="original board" width="400" onmouseover="this.width='1800'" onmouseout="this.width='400'" />
        <figcaption style="display:block; color:grey">Modified Board,
          <b style="color:white">WHITE</b> is the deleted (removed) trace and
          <b style="color:green">GREEN</b> is the new connection.</figcaption>

        <img src="top-64-mod1.png" alt="original schematic" width="300" onmouseover="this.width='800'" onmouseout="this.width='300'" />
        <figcaption style="display:block; color:grey">The top layer showing the modification,
          <b style="color:red">RED</b> is the deleted (removed) trace and
          <b style="color:green">GREEN</b> is the new connection.</figcaption>
      </figure>
      <br>
      I also added a pull-up resistor for <code>RST</code>.
      <br>
      <h4>Modified (rev-1) Eagle files for download:-&gt;</h4>
      <a href="ss-test-rev1.sch" download="sibu-stepper-servo-tester-rev1.sch">Schematic</a>.
      <a href="ss-test-rev1.brd" download="sibu-stepper-servo-tester-rev1.lbr">Board</a>.
    </p>

    <h4>Make the ATTINY44 Run at 8MHz Using the Internal RC Oscillator.</h4>

    <p>
      The ATTINY44 will, out-of-the-box, run at 1MHZ using the internal RC oscillator. The internal RC oscillator will always run at 8MHZ. Out the box the chip is set to use a 1/8 scaling
      as the operating frequency, to change this we need to edit the fuse.
      <br> To operate the Attiny44 at 8 MHz using the internal oscillator the low fuse (lfuse) has to be changed to (from the default value of <code>0x62</code>) <code>0xE2</code>.
      <code>avrdude -P usb -b 19200 -c usbtiny -p  t44 -U lfuse:w:0xE2:m</code>
      <figure>
        <img src="1mhz.png" alt="default" width="600" onmouseover="this.width='1800'" onmouseout="this.width='600'" />
        <figcaption style="display:block; color:grey">Default fuse settings or factory settings.</figcaption>
        <img src="8mhz.png" alt="default" width="600" onmouseover="this.width='1800'" onmouseout="this.width='600'" />
        <figcaption style="display:block; color:grey">Fuse settings for 8MHz, disabling <code>CKDIV8</code>.</figcaption>
      </figure>
      The fuse values was calculated based on the data from the data sheet and confirmed with the help of this
      <a href="http://www.engbedded.com/fusecalc/">Fuse Calculator.</a>
    </p>

    <h2>First step, Trying to use the Rotary Switch.</h2>

    <p>
      The first step is to get the Rotary switch to work. The Rotary switch has two power connectors, and three data lines, two for rotary switch and one for inbuilt push button. The outputs
      from the rotary switch is digital pulses. The other line for push button goes high when the button is pressed. The Push button I have has PCB witha few current limiting, pull
      down resistors, but no denouncing capacitors.
    </p>
    <p>
      From my research, I found that the rotary switch output lines change state when rotated by a step, though they are not in sync/phase. Both of the outputs change state when the position
      of the rotary switch change, though one of them toggle before the other one. Lets call the rotary switch outputs as 'A' and 'B'. The function is like this, the data line 'A' always
      toggles first when the knob is rotated clockwise, and the B toggles just a while after. When rotated counter-clockwise, 'B' toggles first followed by 'A', always. So we can detect
      the direction of rotation by checking which of the pins toggles first.
    </p>

    <h4>A few of the resources:-</h4>

    <p>
      <a href="http://www.allaboutcircuits.com/projects/how-to-use-a-rotary-encoder-in-a-mcu-based-project/">http://www.allaboutcircuits.com/projects/how-to-use-a-rotary-encoder-in-a-mcu-based-project/</a>
      <br>
      <br>
      <a href="http://bildr.org/2012/08/rotary-encoder-arduino/">http://bildr.org/2012/08/rotary-encoder-arduino/</a>
    </p>

    <h3>Using the Rotary Switch.</h3>
    <p>
      I found about a common method for using the rotary switch. Using the interrupts to detect if the device has been used or not, and then using a code (at interrupt vector) to detect the
      direction of the rotation. One can use the following truth table to identify the direction of rotation.
      <figure>
        <img src="rotary-pulse.png" alt="switch pulse" width="600" />
        <figcaption style="display:block; color:grey">Rotary switch pulse and truth table.
          <br>image courtesy:
          <a href="http://www.allaboutcircuits.com/projects/how-to-use-a-rotary-encoder-in-a-mcu-based-project/">http://www.allaboutcircuits.com/projects/how-to-use-a-rotary-encoder-in-a-mcu-based-project/</a>
        </figcaption>
      </figure>
    </p>
    <p>
      If I have the rotary switch which works like above, there is a way to see of the rotation was clockwise or counter-clockwise. Assume that current pin states are <code>A</code>      and <code>B</code>, and previous pin states are <code>A'</code> and <code>B'</code>. Now if we have a number of the form <code>0bXXXX A'B'AB</code>, the values are unique for
      each step. If you inspect, the last four bits will be.
      <br>
      <code>0100, 0010, 1011, 1101</code> are for CW rotation.
      <br>
      <code>1000, 0001, 0111, 1110</code> are for CCW rotation.
      <br>
    </p>
    <p>
      But if you think these are 8 possible combinations, which could be represented by just 3 bits, so lets see if we can simplify the patterns.
      <br>If we set the highest bit to zero, we get.
      <br>
      <code>0100, 0010, 0011, 0101</code> are for CW rotation.
      <br>
      <code>0000, 0001, 0111, 0110</code> are for CCW rotation.
      <br> in decimals, these values corresponds to
      <br>
      <code>4, 2, 3, 5</code> are for CW rotation.
      <br>
      <code>0, 1, 7, 6</code> are for CCW rotation.
      <br>
      <h4>I Could implement this using the below function</h4>
      <pre>
void update(void)
{
	rotstat *= 4;            //Shift bits to the left by 2 positions converting AB (from last postion) to A'B'

	rotstat |= ( (PINA & 0b10000000) &lt;&lt; 1);      //set Rotary switch output A
	rotstat |= ( (PINB & 0b00000010) &lt;&lt; 0);      //set Rotary switch output B

	rotstat *= 0b00000111;                     //clear all bits but first three.

	if ( rotstat &lt; 2 || rotstat &gt; 5)           //Decide if the rotation was CW or CCW
	{
		step = 1;                           //+1 for CW
		PORTA =  0b00100000;                //turn LED on to indicate CW rotation
	}
	else
	{
		step = -1;                          //-1 for CCW
		PORTA =  0b00000000;                //turn LED off to indicate CCW rotation
	}
} </pre>
    </p>

    <p>
      But I made a logic of my own to use the rotary switch. It might have it's draw backs. The idea is to use both the interprets, and the fact that each step toggles both the pins, 'A'
      and 'B'. So we will have two interrupt vectors, one for each of 'A' and 'B', and we use 'PIN CHANGE INTERRUPTS (PCINT)', which will fire interrupt whenever there is a change of
      logical state in the pins where we enabled the 'pin change interrupts'. Though there we can enable PCINT on almost all digital pins,
      <b style="color:red">THERE ARE ONLY TWO, ACTUAL INTERPRET VECTORS</b> for ATTINY44. In most AVR chips, in my best knowledge, there is only one actual external interrupt vector per port. So we can
      use two interrupts without any difficulty if we connect the pins to two separate ports. But if we are going to use the push-button too, it's going to be difficult. But for the
      time being, we can use it this way.
    </p>
    <p>
      What I'm planning to do is to have an interrupt vector to set a flag <code>skip</code> and update the counter or do whatever action we are supposed to when we rotate the encoder.
      The code is made to just skip the entire action if it sees that the flag <code>skip</code> has been set and clears it. This way for every step, even-though both the interrupts
      get fired, action will be taken only for the first and sets the flag, the second interrupt vector just clears the flag. But when rotated the other way, the second vector takes
      the action and sets the flag and the first vector just clears it, again only one action per step.
      <br>
      <br>
      <h4>The code using the above logic to toggle a couple of LEDs.</h4>
      <div class="codescroll">
        <pre>
#define F_CPU 8000000UL
#include &lt;avr/io.h&gt;
#include &lt;avr/interrupt.h&gt;
int skip = 0;
int main(void)
{
	DDRA = 0b01100000; //Setting LED output pins
	cli();				// disable global interrupts

	//enble pin change interrupts on porta and portb
	GIMSK|= (1&l&lPCIE0) | (1&l&lPCIE1); //PCCIR is GIMSK in attiny

	//enable external interrupts for rotary switch
	PCMSK0 |= (1&l&lPCINT7); //CLK or 'A' of Rotary
	PCMSK1 |= (1&l&lPCINT9); //DT or 'B' of Rotary

	sei();			// enable global interrupts:

	while(1)
	{					//  my program         	}
}

ISR(PCINT0_vect)
{
	if (skip == 1)
		skip = 0;
	else
	{
		PORTA = 0b00000000;
	}
}

ISR(PCINT1_vect)
{
	if (skip == 1)
		skip = 0;
	else
	{
		PORTA = 0b01100000;
	}
}      </pre>
      </div>
    </p>

    <h3>Driving the Servo.</h3>

    <p>
      Driving the servo motor is actually quite easy, with arduino it's very easy, matter of just a few lines of code with all those built-in libraries. With C it's a bit more difficult,
      and if you goof up something while designing the circuit, well, it's even more so!
    </p>
    <p>
      The servo expects 20ms or 50Hz pulse(50Hz for historical reasons
      <!-- TODO: reason? -->) with about 5-10% duty cycle, that is for 0 degree, we will sent pulses of 1ms on time every 20ms, for full 180 degree, we sent 2ms pulse every 20ms. More precisely it is, 1ms
      on and 19ms off for 0 degree and 2ms on and 18ms off for 180 degree. Though from my experience whats more important is the on time. The small variation in pulse frequency doesn't
      matter much as long as the on time remains intact, I think the servo measures the on time rather than the duty cycle.
    </p>
    <p>
      So what did I mess up? Well, I should have connected the Servo to one of the pins which can have PWM pulses controlled by the 16-bit timer/counter, Timer1. The pin I presently connected
      the servo to, is controlled by the 8-bit timer/counter, Timer0. The <code>OC0A</code> pin can have 8bit PWM when the Timer0 is used in PWM mode. But 8-bit resolution is
      not enough to control the servo precisely, with 8-bit we can only have less than 10 discrete position between 0 and 180 deg.
    </p>
    <p>
      So, I could either use 8-bit timer or change the circuit or find some crazy way to actually make a 16-bit PWM with the current setup. First two options are too trivial and doesn't involve
      much learning, I will be just doing what I already know. So I decided to make a 16-bit PWM with the current setup itself.
      <br>
      <br>SPOILER:- it actually works.
    </p>
    <p>
      Okay, I decided to use one of my old program, a blinking LED program made for
      <a href="../w8/w8.html">Embedded Programming</a> module. This program uses internal 16- bit timer/counter and internal interrupts when the timer reaches a particular value, to toggle the LEDs. Here I'm
      going to modify the program to have two interrupts at two preset values, both will toggle the status of the output pin of choice. This technique is effectively like a software
      implementation of PWM. The Timer1 can trigger two separate interrupts, on compare match with two entries, OCR1A and OCR1B. So lets get to it, here is the program.
      <div class="codescroll">
        <pre>
#define F_CPU 8000000UL
#include &lt;avr/io.h&gt;
#include &lt;avr/interrupt.h&gt;
int angle = 90;
int main(void)
{
	DDRA = 0b01100000;         //LED Pins
	DDRB |= (1 &lt;&lt; PB2);    //Servo Pin

	cli();				// disable global interrupts

	TCCR1A = 0;   // initialize Timer1 the 16bit timer
	TCCR1B = 0;
	TCCR1B |= (1 &lt;&lt; CS11);       // 1/8 prescaler:

	OCR1A = angle*11+520;            //scaling 0-180 to 520 to 2500, min 520=0deg 2500=180deg
	OCR1B = 20000;                   //For 20ms cycle

	TIMSK1 |= (1 &lt;&lt; OCIE1A);     // enable timer compare interrupt, on 'A'
	TIMSK1 |= (1 &lt;&lt; OCIE1B);     // enable timer compare interrupt, on 'B'

	sei();			// enable global interrupts:

	while(1)
	{					//  my program       	}
}
ISR(TIM1_COMPB_vect)
{
	PORTA = 0b01100000;      //set LED pins
	PORTB |= (1 &lt;&lt; PB2); //set servo pin, at the beginning of the pulse
	TCNT1 = 0;               //reset the timer to begin the new cycle
}

ISR(TIM1_COMPA_vect)
{
		PORTA = 0b00000000;   //unset LED pins
		PORTB = 0x00;         //unset servo pin
}      </pre>
      </div>
      A strange thing is that if I just swap interrupt vectors, that is, to make <code>ISR(TIM1_COMPA_vect)</code> set the servo and <code>ISR(TIM1_COMPB_vect)</code> unset the servo
      pin, the program doesn't work, reason is yet to be figured out. Ofcourse I'm exchanging the initial values too.
    </p>
    <p>
      I think the program is simple and self explanatory, the calculations for the timer values has been given in
      <a href="../w8/w8.html">Embedded Programming</a> module, not so complicated. But for some reason the actual required values are slightly off. I was expecting the values of OCR1A to be within 1000 and
      2000, 1000 being equivalent for 0 degree, and 2000 for 180 degree. Well the actual values are off, 520 and 2500, found after trial and error. I need to access a DSO and find out
      what happened.
    </p>

    <h3>Controlling the Servo with the Rotary Switch</h3>
    <p>
      Now we can put the programs together so that we can rotate the knob to turn the servo back and forth. Here is the program which does this, it's just a combination of the previous two
      programs.
      <div class="codescroll">
        <pre>
#define F_CPU 8000000UL
#include &lt;avr/io.h&gt;
#include &lt;avr/interrupt.h&gt;
int skip = 0;
int angle = 0;
int main(void)
{
  DDRA = 0b01100000;          //LED Pins
  DDRB |= (1 &lt;&lt; PB2);     //Servo Pin

  cli();				// disable global interrupts

  TCCR1A = 0;   // initialize Timer1 the 16bit timer
  TCCR1B = 0;
  TCCR1B |= (1 &lt;&lt; CS11);       // 1/8 prescaler:

  //OCR1A = angle*11+520;          //scaling 0-180 to 520 to 2500, min 520=0deg 2500=180deg
	OCR1B = 20000;                   //For 20ms cycle

	TIMSK1 |= (1 &lt;&lt; OCIE1A);     // enable timer compare interrupt, on 'A'
	TIMSK1 |= (1 &lt;&lt; OCIE1B);     // enable timer compare interrupt, on 'B'

	//enble pin change interrupts on porta and portb
	GIMSK |= (1&lt;&lt;PCIE0) | (1&lt;&lt;PCIE1); //PCCIR is GIMSK in attiny

	//enable external interrupts for rotary switch
	PCMSK0 |= (1&lt;&lt;PCINT7);     //CLK of Rotary
	PCMSK1 |= (1&lt;&lt;PCINT9);     //DT of Rotary
	//PCMSK1 |= (1&lt;&lt;PCINT8);   //push button of Rotary

	sei();			                   // enable global interrupts:

	while(1)
	{
		OCR1A = angle*11+520;       //update timer values to control the PWM
	}
}

ISR(TIM1_COMPA_vect)
{
	PORTB = 0x00;               //unset servo pin
}

ISR(TIM1_COMPB_vect)
{
	PORTB |= (1 &lt;&lt; PB2);    //set servo pin
	TCNT1 = 0;                  //reset timer to start the cycle over.
}

ISR(PCINT0_vect)
{
	if (skip == 1)
		skip = 0;                 //unset skip flag
	else                        //update angle if skip flag is unset
	{
		angle -= 1;
		PORTA = 0b00000000;       //toggle LED pins
		if (angle &lt; 0)          //keep the min angle at 0 degree
			angle = 0;
		skip = 1;                 //set skip flag
	}
}
ISR(PCINT1_vect)
{
	if (skip == 1)
		skip = 0;                 //unset skip flag
	else                        //update angle if skip flag is unset
	{
		angle += 1;
		PORTA = 0b01100000;       //toggle LED pins
		if (angle &gt; 180)        //keep the max angle at 180 degree
			angle = 180;
		skip = 1;                 //set skip flag
	}
}      </pre>
      </div>
    </p>

    <h2>Another Logic to Interpret Data From Rotary Switch</h2>
    <p>
      I had to do this because I found, on inspection with DSO, that the Rotary switch pulses are actually slightly different. During rotation, during each step, both the pins goes low and
      comes back to high, in another words the Pins stays high, during the 'stable' positions of the rotary switch. Same with the push button, it normally stays high.
    </p>
    <p>
      What you are seeing below is my drawing of the pulse generated at A and B, when the rotary switch transitions from one stable position to the next (not full 360 deg). Also Assume that
      we enabled the pin-change-interrupt on A.
    </p>
    <p>
      <figure>
        <img src="interrupt.svg" alt="box" width="600" onmouseover="this.width='900'" onmouseout="this.width='600'" />
        <figcaption style="display:block; color:grey"> </figcaption>
      </figure>
      As you can see, there will be two interrupts fired on each step of the rotary switch. We need to ignore the second one. Also notice two important things, If we execute a code Immediately
      after the interrupt, for example the interrupt vector the code will see that
      <ol>
        <li> <code>A &ne; B</code> for CW and <code>A = B</code> for CCW. </li>
        <li> First interrupt is always on falling edge, means <code>A = 0</code> immediately after the first interrupt.</li>
      </ol>
      <br>SO the interrupt code could be
      <pre>
        if ( A == 0 )
          if ( B == 1 )
            step = 1;     // CW rotation on A = 0 and B = 1
          else            // means B = 0
            step = -1;    // CCW rotation on A = 0 and B = 0</pre>
    </p>
    <h4>Code Using the Above Logic.</h4>
    <div class="codescroll">
      <pre>
#define F_CPU 8000000UL
#include &lt;avr/io.h&gt;
#include &lt;avr/interrupt.h&gt;

void update(void);                // function declaration

int angle = 90;
int step = 0 ;

int main(void)
{
	DDRA = 0b01100000;
	DDRB |= (1 &lt;&lt; PB2);

	cli();                           // disable global interrupts
	// initialize Timer1 the 16bit timer
	TCCR1A = 0;
	TCCR1B = 0;


	OCR1B = 20000;                        // set compare match register to desired timer count:
	TCCR1B |= (1 &lt;&lt; CS11);          // Use CS10, CS11 and CS12 bits for 1/8 prescaler:
	// enable timer compare interrupt:
  TIMSK1 |= (1 &lt;&lt; OCIE1B);
	TIMSK1 |= (1 &lt;&lt; OCIE1A);

	//enble pin change interrupts on porta and portb
	GIMSK |= (1&lt;&lt;PCIE0) | (1&lt;&lt;PCIE1); //PCICR is GIMSK in attiny

	//enable external interrupts for rotary switch
	PCMSK0 |= (1&lt;&lt;PCINT7);          //CLK of Rotary
	//PCMSK1 |= (1&lt;&lt;PCINT9);        //DT of Rotary
	//PCMSK1 |= (1&lt;&lt;PCINT8);        //push button of Rotary

	sei();                                // enable global interrupts:

	while(1)
	{
		OCR1A = angle*11+520;
	}
}

ISR(TIM1_COMPA_vect)
{
	PORTB = 0x00;
}

ISR(TIM1_COMPB_vect)
{
	PORTB |= (1 &lt;&lt; PB2);
	TCNT1 = 0;
}

ISR(PCINT1_vect)
{

}
ISR(PCINT0_vect)
{
	if ((PINB & 0b00000001))
	{
		update();
		PORTA ^=  0b01000000;
	}

	angle += step;
	step = 0;
	if (angle &gt; 180)
		angle = 180;
	else if (angle &lt; 0)
		angle = 0;
}
void update(void)
{
	if ( PINA & 0b10000000 )
		if ( PINB & 0b00000010 )
		{
			step = 1;                     //+1 for CW
			PORTA =  0b00100000;
		}
		else
		{
			step = -1;                    //-1 for CCW
			PORTA =  0b00000000;
		}
}      </pre>
    </div>

    <h2>Stepper</h2>
    <p>
      Controlling the stepper motor with the Micr-Controller and the A4988 driver is very easy. At bare minimum, the driver need only two inputs from the Micro-Controller,
      <ul>
        <li>Step:- This is input is given as pulses, the frequency of which determines the rotational frequency of the motor, and the number of pulses corresponds to number of steps. So
          if we need the stepper to move 10 steps, we just give 10 pules, and the rate at which we give the pulse determines how fast the stepper moves those 10 steps.</li>
        <li>Dir:- This controls the direction in which the stepper moves. This pin can be High or Low, and obviously high and low corresponds to the CW and CCW rotations.</li>
      </ul>
      Then there are more pins which we could use or somehow bypass. Including
      <br>
      <br>
      <ul>
        <li><code>MS1, MS2, MS3</code> :- Micro-stepping selection
          <br> Normally low, could be set high as per the table to enable micro-stepping for higher resolution movements.
          <br>
          <img src="micro-step.png" alt="debug-2" width="500" onmouseover="this.width='700'" onmouseout="this.width='500'">
          <br>
        </li>
        <li><code style="text-decoration: overline">Enable</code>:- (Normally Low) Setting this Pin High, will disable the FETs in the chip, killing the power to the motor.</li>
        <li><code style="text-decoration: overline">Sleep</code>:- (Normally High) Set this pin Low to put the chip in sleep mode to save power when the Motor/Chip is not in use.</li>
        <li><code style="text-decoration: overline">Reset</code>:- (Normally Floating) This is a floating pin and should be kept high to use the motor normally, when set low the motor shall
          return to the original position the motor was in when the chip was turned on. Should refer to the Data-sheet for more information. If this pin is low all STEP signals are
          ignored.
        </li>
      </ul>

      <h3>Below is the Code For Controlling the Speed and Direction of the Stepper Motor Using the Rotary Switch.</h3>

      <div class="codescroll">
        <pre>
#define F_CPU 8000000UL
#include &lt;avr/io.h&gt;
#include &lt;avr/interrupt.h&gt;
/*
  PA0		dir
  PA1		step
  PA2		sleep
  PA3		reset
  PA4		enable
  PA5		orange LED
  PA6		Blue LED

  Rotate the knob to adjust the speed of rotation and use the built-in push-button to toggle the direction.
 */

int temp = 20000;
int step = 1000;

void update(void);

int main(void)
{
	DDRA |= (1 &lt;&lt; PA6) | (1 &lt;&lt; PA5) | (1 &lt;&lt; PA4) |  (1 &lt;&lt; PA3) |(1 &lt;&lt; PA2) | (1 &lt;&lt; PA1) | (1 &lt;&lt; PA0);
	PORTA |= (0 &lt;&lt; PA5);  //orange led
	// initialize Timer1 the 16bit timer
	cli();				// disable global interrupts
	TCCR1A = 0;
	TCCR1B = 0;

	// set compare match register to desired timer count:
	OCR1A = temp;

	TCCR1B |= (1 &lt;&lt; WGM12);		// turn on CTC mode:
	TCCR1B |= (1 &lt;&lt; CS11);		// Use CS10, CS11 and CS12 bits for 1/8 prescaler:

	// enable timer compare interrupt:
	TIMSK1 |= (1 &lt;&lt; OCIE1A);

	//enble pin change interrupts on porta and portb
	GIMSK |= (1&lt;&lt;PCIE0) | (1&lt;&lt;PCIE1); //PCICR is GIMSK in attiny

	//enable external interrupts for rotary switch
	PCMSK0 |= (1&lt;&lt;PCINT7); //CLK of Rotary
	PCMSK1 |= (1&lt;&lt;PCINT8); //push button of Rotary

	sei();			// enable global interrupts:

	PORTA |= (1&lt;&lt;PA3) | (1&lt;&lt;PA2);   //sleep and reset
	PORTA |=  (0 &lt;&lt; PA4);			//enable
	while(1)
	{
		OCR1A = temp;
	}
}

ISR(TIM1_COMPA_vect)
{
	PORTA ^= (1&lt;&lt;PA1);
	PORTA ^= (1&lt;&lt;PA5);
}
ISR(PCINT1_vect)
{
	if ((PINB & 0b00000001))
	{
		PORTA ^=  (1&lt;&lt;PA6);
		PORTA ^=  (1&lt;&lt;PA0);		//change direction on push button
	}
}

ISR(PCINT0_vect)
{
	if ((PINB & 0b00000001))
		update();
}
void update(void)
{
	if ( PINA & 0b10000000 )
		if ( PINB & 0b00000010 )
			temp -= step;
		else
			temp += step;
	step = temp/30;
	if (temp &gt; 25000)
		temp = 25000;
	if (temp &lt; 600)
		temp=600;
	if (step &lt; 10)
		step = 10;
}        </pre>

      </div>
    </p>





    <h2 style="color:red">Fixing the wrong FUSE settings.</h2>
    <p>
      AT one stage I antecedently flashed the chip with a FUSE setting that makes the chip to use external clock source, but as you can see I don't have an external clock source and I have
      used almost all pins on the chip including the pins where we would connect the external crystal/resonator. What happened was, instead of setting the <code>lfuse</code> as
      <code>0xE2</code> or <code>0x62</code> which would use internal clock, I accidentally set the fuse to <code>0xFF</code> which makes the chip to wait for external clock.
    </p>
    <p>
      Once this was done there is no easy way back, the chip now requires external clock to function. So I had to give it one. I could use
      <ul>
        <li>a function generator to give external clock</li>
        <li>or an external crystal/resonator</li>
      </ul>
      I decided to use an external resonator,
    </p>
    <p>
      <figure>
        <img src="reson.jpg" alt="box" width="600" onmouseover="this.width='900'" onmouseout="this.width='600'" />
        <figcaption style="display:block; color:grey"> The resonator with jumper wires soldered to the three pads.
        </figcaption>
      </figure>
      But still I had to remove the rotary switch and connect the resonator to the main circuit, I just had to keep the resonator wires touching the corresponding Micro-controller pins for
      a few seconds, enough for a friend to execute the command to flash the correct fuses.
    </p>
    <br>
    <br>
    <h2 style="color:red">De-bouncing.</h2>
    <p>
      The bouncing effect happens with almost every mechanical switches, the contact will become permanent only after some bouncing. As the name suggest, when you make contact its not made
      instantly, it settles down only after a few bouncing around. This causes multiple inputs or in-case of interrupts, will fire multiple interrupts instead of one. There are multiple
      solutions to de-bounce, you can do it in software by introducing a delay after the first input to ignore all the following bounces, or make the program to skip all the inputs
      except for the first one, coming in a very short time, which would be improbable to be done by a human.
    </p>
    <p>
      Another solution is hardware based, a capacitor of the right value, to smooth-out any short pulses. The capacitance cannot be too high as this will capacitor will take a long time to
      get charged and once it does, it maintains that charge for some time, this will result in poor response time and will also skip inputs if given too fast. Too small capacitance
      will not fix the bouncing issue. Generally <code>100 nF</code> capacitor is recommended. So I soldered 3 <code>100 nF</code> 0805 capacitors I had in my personal inventory
      (FabLab do not have 100nF) to the two rotary output pins and the push button pin of the rotary switch. I also put bit of hot-melt-glue to keep them in place. The capacitors were
      all connected between the corresponding pins and GND.
      <figure>
        <img src="bounce.jpg" alt="box" width="600" onmouseover="this.width='900'" onmouseout="this.width='600'" />
        <figcaption style="display:block; color:grey"> The de-bouncing capacitors buried under the hot-melt-glue, you can also see the ground wire.
        </figcaption>
      </figure>
    </p>
  </section>

</body>

</html>
